<?php 
class App {
  /**
   * Looks for the root path of application
   *
   * @return string
   */
  public static function path( $name = '', $ext = '.php' ){
    static $path = NULL;

    if( $path == NULL ) {
      $path = (new ReflectionClass( 'App' ))->getFilename();
      $path = dirname( dirname( $path ) ) . DIRECTORY_SEPARATOR;
    }

    if( is_array( $name ) ) {
      $name = join( DIRECTORY_SEPARATOR, $name );
    }

    if( $name && $ext ) {
      $name .= $ext;
    }    

    return $path . strtolower( $name );
  }

  /**
   * Renders a view file.
   * This method includes the view file as a PHP script
   * and captures the display result if required.
   * @param string $_viewFile_ view file
   * @param array $_data_ data to be extracted and made available to the view file
   * @param boolean $_return_ whether the rendering result should be returned as a string
   * @return string the rendering result. Null if the rendering result is not required.
   */
  public static function renderFile( $_data_ = null, $_viewFile_ = null, $_return_ = false ) {
    // we use special variable names here to avoid conflict when extracting data
    if( is_array( $_data_ ) ) {
      extract( $_data_, EXTR_PREFIX_SAME, 'data' );
    } else {
      $data = $_data_;
    }

    if( $_return_ ) {
      ob_start();
      ob_implicit_flush( false );
      require( $_viewFile_ );
      return ob_get_clean();
    } else {
      require( $_viewFile_ );
    }
  }

  /**
   * Creates a cell and executes it.
   * @param string $className the widget class name or class in dot syntax
   * @param array $properties list of initial property values for the widget (Property Name => Property Value)
   * @param boolean $captureOutput whether to capture the output of the widget. If true, the method will capture
   * and return the output generated by the widget. If false, the output will be directly sent for display
   * and the widget object will be returned. This parameter is available since version 1.1.2.
   * @return mixed the widget instance when $captureOutput is false, or the widget output when $captureOutput is true.
   */
  public static function cell( $className, $properties = array(), $captureOutput = false ) {
    $path = str_replace( '_', DIRECTORY_SEPARATOR, $className );

    $pathCtrl = self::path( array( 'controller',  $path ) );
    $pathView = self::path( array( 'view', $path ) );  
    
    if( !file_exists( $pathCtrl ) && file_exists( $pathView ) ) {
      require( $pathView );
      return;
    }

    $widget = self::newObject( $className . '_Controller', $properties );

    if( $captureOutput ) {
      ob_start();
      ob_implicit_flush(false);
      try {
        $widget->run();
      } catch(Exception $e) {
        ob_end_clean();
        throw $e;
      }
      return ob_get_clean();
    } else {
      $widget->run();
    }
  }

    /**
     * Creates a new class instance.
     *
     * @param string $class The class name.
     * @param array $attr optional attributes assigned to the object after initialization.
     * @return object.
     */
    public static function newObject( $class, $attr = array() ) {
        $obj = new $class();
            
        if( !empty( $attr ) ) {
            foreach( $attr as $key => $val ) {
                $obj->{$key} = $val;
            }
        }
        
        if(method_exists($obj, 'init')){
            $obj->init();
        }

        return $obj;
    }

    /**
     * Retrieve value from the config file.
     *
     * @param string $name The key name of first level.
     * @param string $field optional The key name of second level.
     * @return mixed.
     */
    public static function getConfig( $name, $def = NULL ) {
        static $setting = false;
        if( $setting == false ) {
            $setting = require( self::path( array( 'config', 'config' ) ) );
        }
        
        return self::find( $name, $setting, $def );
    }

  /**
   * Get item from array by key with mutil level  
   */
    public static function find($name, $data = NULL, $def = NULL ){
        $value = $data;
        
        foreach( preg_split( "/[\.]+/", $name ) as $key ) {
            if( is_array( $value ) && isset( $value[ $key ] ) ) {
                $value = $value[ $key ];
            }
            else $value = $def;
        }
        
        return $value;
    }

  /**
   * DB Instance  
   */
 public static function db(){
   static $instance = null;

    if( $instance == null ) {
      $class = App::getConfig( 'db.driver' );

      $instance = new $class();
      $instance->connect( 
            App::getConfig( 'db.host' ),
            App::getConfig( 'db.user' ),
            App::getConfig( 'db.pass' ),
            App::getConfig( 'db.name' ),
            App::getConfig( 'db.port', false ),
            App::getConfig( 'db.persistent', false )
      );
    }

		return $instance;
 }  

  /**
   * Autoload class  
   */
  public static function autoload( $name ){
    if( preg_match( '/^(.+)\_(controller|model)$/i', $name, $matches ) ) {
      
      $name = str_replace( '_', DIRECTORY_SEPARATOR, $matches[1] );
      $path = App::path( array( $matches[2],  $name  ) );
    } else {

      $name = str_replace( '_', DIRECTORY_SEPARATOR, $name );
      $path = App::path( array( 'class',  $name ) );
    }

    if( is_file( $path ) && file_exists( $path ) ) {
      require_once( $path );
    }
  }
}

spl_autoload_register( array( 'App', 'autoload' ) );
?>
