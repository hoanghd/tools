<?php
class Controller {  
  public $layout = NULL;
  public $view = NULL;

  public function run(){}

  /**
	 * Renders a view with a layout.
	 *
	 * @param string $view name of the view to be rendered. See {@link getViewFile} for details
	 * about how the view script is resolved.
	 * @param array $data data to be extracted into PHP variables and made available to the view script
	 * @param boolean $return whether the rendering result should be returned instead of being displayed to end users.
	 * @return string the rendering result. Null if the rendering result is not required.
	 * @see renderPartial
	 * @see getLayoutFile
	 */
	public function render( $data = null, $return = false) {
		$output = $this->renderFile( $data, $this->getViewFile(), true );
        if ( ( $layoutFile = $this->getLayoutFile() ) !== false ) {
            $output = $this->renderFile( array( 'content' => $output ), $layoutFile, true );
        }            
        
        if ( $return ) {
            return $output;
        } else {
            echo $output;
        }
	}
  
  /**
   * Renders a view file.
   * This method includes the view file as a PHP script
   * and captures the display result if required.
   * @param string $_viewFile_ view file
   * @param array $_data_ data to be extracted and made available to the view file
   * @param boolean $_return_ whether the rendering result should be returned as a string
   * @return string the rendering result. Null if the rendering result is not required.
   */
  public function renderFile( $_data_ = null, $_viewFile_ = null, $_return_ = false ) {
    // we use special variable names here to avoid conflict when extracting data
    if( is_array( $_data_ ) ) {
      extract( $_data_, EXTR_PREFIX_SAME, 'data' );
    } else {
      $data = $_data_;
    }

    if( $_return_ ) {
      ob_start();
      ob_implicit_flush( false );
      require( $_viewFile_ );
      return ob_get_clean();
    } else {
      require( $_viewFile_ );
    }
  }
  
  /**
   * Looks for the view file according to the given view name.
   *
   * @return string the view file path, false if the view file does not exist
   */
  public function getViewFile() {
    if( $this->view == NULL ) {
        $this->view = str_replace( '_', DIRECTORY_SEPARATOR, substr( get_called_class(), 0, -11 ) );
    } else if( is_file( $this->view ) && file_exists( $this->view ) ) {
        return $this->view;
    }

    return $this->rootDir( array( 'view', $this->view . '.php' ) );
  } 

  /**
   * Looks for the view file according to the given view name.
   *
   * @return string the view file path, false if the view file does not exist
   */
  public function getLayoutFile() {
    if( $this->layout == NULL ) {
        return false;
    }

    return $this->rootDir( array( 'view', $this->layout . '.php' ) );
  }

  /**
   * Looks for the root path of application
   *
   * @return string
   */
  public function rootDir( $name = '' ){
    static $path = NULL;

    if( $path == NULL ) {
      $path = (new ReflectionClass( 'Controller' ))->getFilename();
      $path = dirname( dirname( $path ) ) . DIRECTORY_SEPARATOR;
    }

    if( is_array( $name ) ) {
      $name = join( DIRECTORY_SEPARATOR, $name );
    }

    return $path . $name;
  }

  /**
   * Creates a widget and executes it.
   * @param string $className the widget class name or class in dot syntax (e.g. application.widgets.MyWidget)
   * @param array $properties list of initial property values for the widget (Property Name => Property Value)
   * @param boolean $captureOutput whether to capture the output of the widget. If true, the method will capture
   * and return the output generated by the widget. If false, the output will be directly sent for display
   * and the widget object will be returned. This parameter is available since version 1.1.2.
   * @return mixed the widget instance when $captureOutput is false, or the widget output when $captureOutput is true.
   */
  public static function widget( $className, $properties = array(), $captureOutput = false ) {
    $className .= '_controller';
    $widget = new $className();

    foreach( $properties as $name => $value ) {
      $widget->$name = $value;
    }

    if( $captureOutput ) {
      ob_start();
      ob_implicit_flush(false);
      try {
        $widget->run();
      } catch(Exception $e) {
        ob_end_clean();
        throw $e;
      }
      return ob_get_clean();
    } else {		
      $widget->run();
    }
  }
}
?>
